namespace ml.delegateMixin

  ' /**
  '  * @member setDelegate
  '  * @memberof module:delegateMixin
  '  * @instance
  '  * @function
  '  * @description description
  '  * @param {MList} list instance to add delegate methods for
  '  * @param {class} instance, target for the delegate methods - if invalid, then methods will be called on m
  '  * @returns {returnType} returnDescription
  '  */
  function setListDelegate(list, instance = invalid)
    if instance = invalid
      instance = m
    end if

    ml.delegateMixin.setListRowDelegate(list, instance)
    ml.delegateMixin.setListCellDelegate(list, instance)

    if m.isObservingCellEvents or m.isObservingRowEvents
      m.listDelegate = instance
    else
      m.listDelegate = invalid
    end if

    ? "SET LIST DELEGATE: CE "; m.isObservingCellEvents ; " RE " ; m.isObservingRowEvents
    ml.delegateMixin.toggleDelegateActive(list, m.isObservingCellEvents or m.isObservingRowEvents)

  end function

  function toggleDelegateActive(list, isActive)
    ? "TOGGLE ACTIVE "; isActive
    if isActive
      if m.isObservingCellEvents
        ? "LISTENING TO CELL EVENTS"
        mc.toggleObserver(list.cellEvents, "listEvent", mc.getFunctionName(ml.delegateMixin.onCellEventBridge))
        mc.toggleObserver(list.cellEvents, "viewportEvents", mc.getFunctionName(ml.delegateMixin.onCellEventsBridge))
      end if

      if m.isObservingRowEvents
        ? "LISTENING TO ROW EVENTS"
        mc.toggleObserver(list.rowEvents, "listEvent", mc.getFunctionName(ml.delegateMixin.onRowEventBridge))
        mc.toggleObserver(list.rowEvents, "viewportEvents", mc.getFunctionName(ml.delegateMixin.onRowEventsBridge))
      end if
    else
      mc.toggleObserver(list.cellEvents, "listEvent")
      mc.toggleObserver(list.cellEvents, "viewportEvents")
      mc.toggleObserver(list.rowEvents, "listEvent")
      mc.toggleObserver(list.rowEvents, "viewportEvents")
    end if
  end function

  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  '++ cells
  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  function setListCellDelegate(list, instance = invalid)
    m.listCellEventMap = {}

    if instance <> invalid
      funcMap = {
        "onCellWillEnter": "willEnter"
        "onCellWillExit": "willExit"
        "onCellDidEnter": "didEnter"
        "onCellDidExit": "didExit"
        "onCellWillGainFocus": "willGainFocus"
        "onCellWillLoseFocus": "willLoseFocus"
        "onCellDidGainFocus": "didGainFocus"
        "onCellDidLoseFocus": "didLoseFocus"
        "onCellGainingFocus": "gainingFocus"
        "onCellLosingFocus": "losingFocus"
      }

      for each funcName in funcMap
        if mc_isFunction(instance[funcName])
          m.listCellEventMap[funcMap[funcName]] = funcName
        end if
      end for
    end if

    m.isObservingCellEvents = m.listCellEventMap.count() > 0
  end function

  function onCellEventBridge(sgEvent) as void
    if m.isObservingCellEvents
      ml.delegateMixin.handleCellEvent(sgEvent.getData())
    end if
  end function

  function onCellEventsBridge(sgEvent) as void
    ? "CELL EVENT BRIDGE 1"
    if m.isObservingCellEvents
      ? "CELL EVENT BRIDGE 2"
      for each event in sgEvent.getData()
        ml.delegateMixin.handleCellEvent(event)
      end for
    end if
  end function

  function handleCellEvent(event) as void
    eventName = event.name
    if not m.isObservingCellEvents or m.listCellEventMap[eventName] = invalid
      ' ? "LE(skipped) " ; eventName ; " " ; event.direction ; " I " ; "" ; event.index ; " " ; event.fraction
      return
    end if
    ' ? "onListEventBridge OBSERVED " ; eventName

    if eventName = "gainingFocus" or eventName = "losingFocus"
      m[m.listCellEventMap[eventName]](event.rowIndex, event.index, event.direction, event.fraction)
    else
      m[m.listCellEventMap[eventName]](event.rowIndex, event.index, event.direction)
    end if

  end function

  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  '++ rows
  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  function setListRowDelegate(list, instance = invalid)
    m.listRowEventMap = {}

    if instance <> invalid
      funcMap = {
        "onRowWillEnter": "willEnter"
        "onRowWillExit": "willExit"
        "onRowDidEnter": "didEnter"
        "onRowDidExit": "didExit"
        "onRowWillGainFocus": "willGainFocus"
        "onRowWillLoseFocus": "willLoseFocus"
        "onRowDidGainFocus": "didGainFocus"
        "onRowDidLoseFocus": "didLoseFocus"
        "onRowGainingFocus": "gainingFocus"
        "onRowLosingFocus": "losingFocus"
      }

      for each funcName in funcMap
        if mc_isFunction(instance[funcName])
          m.listRowEventMap[funcMap[funcName]] = funcName
        end if
      end for
    end if

    m.isObservingRowEvents = m.listRowEventMap.count() > 0
  end function

  function onRowEventBridge(sgEvent) as void
    if m.isObservingRowEvents
      ml.delegateMixin.handleRowEvent(sgEvent.getData())
    end if
  end function

  function onRowEventsBridge(sgEvent) as void
    if m.isObservingRowEvents
      for each event in sgEvent.getData()
        ml.delegateMixin.handleRowEvent(event)
      end for
    end if
  end function

  function handleRowEvent(event) as void
    eventName = event.name
    if not m.isObservingRowEvents or m.listRowEventMap[eventName] = invalid
      ' ? "LE(skipped) " ; eventName ; " " ; event.direction ; " I " ; "" ; event.index ; " " ; event.fraction
      return
    end if
    ' ? "o  ListEventBridge OBSERVED " ; eventName

    if eventName = "gainingFocus" or eventName = "losingFocus"
      m.listDelegate[m.listEventMap[eventName]](event.index, event.direction, event.fraction)
    else
      m.listDelegate[m.listEventMap[eventName]](event.index, event.direction)
    end if

  end function

end namespace